"""Service prefix middleware.

Allows the service to be accessed with a /<service-name> prefix:
- /api/<service-name>/v1/users -> /api/v1/users
- /<service-name>/ping -> /ping

For the /api/<service-name> case, no SCRIPT_NAME is set so reverse()
generates canonical /api/... URLs.

For the /<service-name> case, SCRIPT_NAME is set so reverse()
generates /<service-name>/... URLs.

The service prefix can be configured via the SERVICE_PREFIX setting,
which defaults to the ROOT_URLCONF module name (e.g., 'inventory_service'
-> 'inventory-service'). When deployed behind a gateway with a different
slug (e.g., api_slug: 'inventory'), set SERVICE_PREFIX = 'inventory'
so URLs generated by the service match the external gateway path.
"""
from django.conf import settings
from django.urls import set_script_prefix


def _has_prefix(path, prefix):
    """Check if path starts with prefix at a segment boundary.

    Returns True if path equals prefix or starts with prefix followed by '/'.
    This prevents '/metrics-servicefoo' from matching prefix '/metrics-service'.
    """
    return path == prefix or path.startswith(prefix + "/")


class ServicePrefixMiddleware:
    """
    Middleware that handles /<service-name> prefix in URLs.

    Two routing modes:
    1. /api/<service-name>/... -> /api/... (no SCRIPT_NAME, canonical URLs)
    2. /<service-name>/... -> /... (SCRIPT_NAME set for prefixed URLs)
    """

    def __init__(self, get_response):
        self.get_response = get_response
        # Use SERVICE_PREFIX setting if available, otherwise derive from ROOT_URLCONF
        default_name = settings.ROOT_URLCONF.split(".")[0].replace("_", "-")
        self.service_name = getattr(settings, "SERVICE_PREFIX", default_name)
        self.service_prefix = f"/{self.service_name}"

        # Also recognize the internal name for direct pod access
        self._internal_name = default_name
        self._internal_prefix = f"/{default_name}"

    def _match_prefix(self, path):
        """Return the matching prefix and mode, or (None, None)."""
        api_prefix = f"/api{self.service_prefix}"
        if _has_prefix(path, api_prefix):
            return api_prefix, "api"

        # Also accept internal name (e.g., /api/inventory-service/) for direct access
        if self.service_name != self._internal_name:
            internal_api_prefix = f"/api{self._internal_prefix}"
            if _has_prefix(path, internal_api_prefix):
                return internal_api_prefix, "api"

        if _has_prefix(path, self.service_prefix):
            return self.service_prefix, "script"

        if self.service_name != self._internal_name:
            if _has_prefix(path, self._internal_prefix):
                return self._internal_prefix, "script"

        return None, None

    def __call__(self, request):
        path = request.path_info
        matched_prefix, mode = self._match_prefix(path)

        if mode == "api":
            # Handle /api/<service-name>/... -> /api/...
            # Always use the external prefix for generated URLs
            external_api_prefix = f"/api{self.service_prefix}"
            request._original_path = path
            request._api_service_prefix = external_api_prefix
            new_path = "/api" + path[len(matched_prefix):] or "/api/"
            request.path_info = new_path
            request.path = new_path
            if hasattr(request, "environ"):
                request.environ["PATH_INFO"] = new_path

            original_get_full_path = request.get_full_path

            def patched_get_full_path(force_append_slash=False):
                canonical = original_get_full_path(force_append_slash)
                if canonical.startswith(("/api/", "/api?")):
                    return external_api_prefix + canonical[4:]
                return canonical

            request.get_full_path = patched_get_full_path

        elif mode == "script":
            # Handle /<service-name>/... -> /...
            external_prefix = self.service_prefix
            request._original_path = path
            new_path = path[len(matched_prefix):] or "/"
            request.path_info = new_path
            request.path = new_path
            request.META["SCRIPT_NAME"] = external_prefix
            set_script_prefix(external_prefix)
            if hasattr(request, "environ"):
                request.environ["SCRIPT_NAME"] = external_prefix
                request.environ["PATH_INFO"] = new_path

            original_get_full_path = request.get_full_path

            def patched_get_full_path(force_append_slash=False):
                return external_prefix + original_get_full_path(force_append_slash)

            request.get_full_path = patched_get_full_path

        return self.get_response(request)
