# WARNING: DO NOT EDIT THIS FILE, IT IS MANAGED BY ANSIBLE-SERVICES-FRAMEWORK.
"""# The main settings for inventory_service.

## On this module

1. Default Settings (regular django settings)
2. Dynaconf instrumentation that loads external settings including
[DAB](https://github.com/ansible/django-ansible-base) defaults

## Loading order

1. Project defaults as defined in the first section of this file.
2. DAB defaults.
3. Application defaults.
   - Top level apps/settings.py
   - Each `app/settings.py` in `apps` directory.
4. DAB conditional settings.
   - Loaded based on what is on current INSTALLED_APPS, MIDDLEWARES etc
5. Overrides from standard paths.
   - /etc/ansible-automation-platform/inventory_service/
6. Overrides from environment variables prefixed with INVENTORY_SERVICE_.
7. Post loading hooks registered on any Python file loaded before.

## Overrides

> [!NOTE]
> To override defaults define variables on each `apps`/app_name/settings.py.
> To override settings on environments use the override path `/etc/...`
> or set environment variables prefixed with `INVENTORY_SERVICE_`.
> The environment variables can also be used on development environments
> by adding a `.env` file to the root of the project or creating a
> `settings.local.py`

## Inspecting settings and troubleshooting

To examine the loading history of the settings loading mechanism.

```bash
# Export the Django Settings Module Variable
export DJANGO_SETTINGS_MODULE=inventory_service.settings

# The whole history
uv run dynaconf inspect -m debug -f yaml

# Inspect a variable
uv run dynaconf inspect -k VARIABLE
```

## Default variables
"""

import os
import sys
from importlib import import_module
from pathlib import Path

from ansible_base.lib.dynamic_config import (
    export,
    factory,
    load_dab_settings,
    load_envvars,
    load_standard_settings_files,
)
from dynaconf.loaders import execute_instance_hooks

BASE_DIR = Path(__file__).resolve().parent.parent
"""Build paths inside the project like this: BASE_DIR / 'subdir'"""

SECRET_KEY = "django-insecure-k^a&fnx3ulh*d2nl%q680o+xkr^5o+c$5=lzo7vd-7=#qmadg("  # noqa
"""SECURITY WARNING: keep the secret key used in production secret!"""

DEBUG = False
"""SECURITY WARNING: don't run with debug turned on in production!"""

ALLOWED_HOSTS = ["*"]
"""List of allowed hosts"""

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
]
"""List of installed apps"""

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    # DAB middlewares
    "crum.CurrentRequestUserMiddleware",
    "ansible_base.lib.middleware.logging.LogRequestMiddleware",
    "ansible_base.lib.middleware.logging.LogTracebackMiddleware",
]
"""List of middleware classes"""


ROOT_URLCONF = "inventory_service.urls"
"""URL configuration for platform_service_example project."""


TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [
            "apps/api/templates",
        ],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]
"""List of template configurations"""


WSGI_APPLICATION = "inventory_service.wsgi.application"
"""WSGI application configuration"""
ASGI_APPLICATION = "inventory_service.asgi.application"
"""ASGI application configuration"""

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    },
    "dispatcher": {},
}
"""Database configuration"""

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]
"""Password validation configuration"""

# Authentication Backends
AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",  # Default Django auth
]

# Session Configuration
SESSION_ENGINE = "django.contrib.sessions.backends.db"

# Security Settings
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = "DENY"

LOG_LEVEL = os.environ.get("INVENTORY_SERVICE_LOG_LEVEL", "INFO").upper()
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "filters": {
        "request_id": {
            "()": "ansible_base.lib.logging.filters.RequestIdFilter",
        },
    },
    "formatters": {
        "simple": {
            "format": "{asctime} {levelname:<8} {name} {message}",
            "style": "{",
        },
        "verbose": {
            "format": "{asctime} {levelname:<8} [{request_id}] {name} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "verbose",
            "filters": ["request_id"],
        },
    },
    "loggers": {
        "ansible_base": {
            "handlers": ["console"],
            "level": LOG_LEVEL,
            "propagate": False,
        },
        "inventory_service": {
            "handlers": ["console"],
            "level": LOG_LEVEL,
            "propagate": False,
        },
        "django": {
            "handlers": ["console"],
            "level": LOG_LEVEL,
            "propagate": False,
        },
        "apps": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False,
        },
        "": {
            "handlers": ["console"],
            "level": LOG_LEVEL,
            "propagate": True,
        },
    },
}

LANGUAGE_CODE = "en-us"
"""Language code for this installation."""

TIME_ZONE = "UTC"
"""Time zone for this installation."""

USE_I18N = True
"""Internationalization configuration"""

USE_TZ = True
"""Time zone configuration"""

STATIC_URL = "static/"
"""Static files configuration"""

STATIC_ROOT = BASE_DIR / "staticfiles"
"""Root directory for static files"""

STATICFILES_DIRS = [
    BASE_DIR / "static",
]
"""Directories to search for static files"""

MEDIA_URL = "media/"
"""Media files URL endpoint"""

MEDIA_ROOT = BASE_DIR / "media"
"""Root directory for media files"""

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
"""Default primary key field type"""

IS_RUNNING_TESTS = "test" in sys.argv or "PYTEST_VERSION" in os.environ
"""Determine if application is running a testing session."""

LOADED_APPS = []
"""List of apps loaded by the Ansible Services Framework dynamically set at runtime."""

default_variables = {k: v for k, v in locals().items() if k.isupper()}
"""Variables from this module locals that will be passed to Dynaconf"""

## --- End Default Settings | Start Dynaconf instrumentation --- #

app_prefix = "INVENTORY_SERVICE"
"""Application prefix for environment variables filtering."""

os.environ.setdefault("INVENTORY_SERVICE_MODE", "development")
environment = os.environ.get("INVENTORY_SERVICE_MODE", "development").lower()
"""The current environment, by default development"""

DYNACONF = factory(__name__, app_prefix, add_dab_settings=False, **default_variables)
"""Dynaconf instance that comes with settings injected by DAB"""

apps_dir = Path(BASE_DIR / "apps")
"""The directory where the django apps will be discovered from"""

apps_settings_dir = apps_dir / "settings"
"""The directory where the django apps will be discovered from"""

# Load top level apps default settings if exists
if (apps_settings := Path(apps_settings_dir / "defaults.py")).exists():
    DYNACONF.load_file(apps_settings, run_hooks=False)

# Developers can enable new apps via envvars and it must load before envvar loading
if dev_installed_apps := os.getenv("DEV_INSTALLED_APPS", ""):
    if not dev_installed_apps.startswith("@"):
        dev_installed_apps = f"@merge_unique {dev_installed_apps}"
    DYNACONF.set("INSTALLED_APPS", dev_installed_apps)

# Load each app settings in the order defined on INSTALLED_APPS
if apps_dir.exists():
    all_apps = [
        app
        for app in DYNACONF.INSTALLED_APPS
        if app.startswith("apps.") and Path(apps_dir / app.removeprefix("apps.").replace(".", "/")).exists()
    ]
    for app in all_apps:
        DYNACONF.load_file(f"{app}.settings", run_hooks=False)
    DYNACONF.set("LOADED_APPS", all_apps)

# Load environment specific default overrides after all apps/ settings.
if (env_settings := Path(apps_settings_dir / f"{environment}.py")).exists():
    DYNACONF.load_file(env_settings, run_hooks=False)

# load local dev settings if exists
if (dev_file := Path(BASE_DIR / "settings.local.py")).exists():
    DYNACONF.load_file(dev_file)

# DAB default and DAB conditionals that needs to load after project and app settings.
load_dab_settings(DYNACONF)

# Load settings overrides from the standard paths, this is the **user** settings.
load_standard_settings_files(DYNACONF)

# Load envvars at the end to allow them to override everything loaded so far.
load_envvars(DYNACONF)

# Build PostgreSQL DATABASES from DB_* env vars (mirrors PSF pattern)
from apps.settings.database import override_database_settings
override_database_settings(DYNACONF)

# Load development only apps
if not DYNACONF.get("IS_RUNNING_TESTS") and DYNACONF.get("DEBUG"):
    try:
        import debug_toolbar  # noqa
    except ImportError:
        pass  # Ignore if debug_toolbar is not installed
    else:
        DYNACONF.set("INSTALLED_APPS", "@merge_unique debug_toolbar")
        DYNACONF.set("MIDDLEWARE", "@merge_unique debug_toolbar.middleware.DebugToolbarMiddleware")
        DYNACONF.set("DEBUG_TOOLBAR_CONFIG", {"SHOW_TOOLBAR_CALLBACK": lambda request: True})

# This executes the hooks deferred from application settings to execute later.
# TODO(rochacbruno): Move this internally to DAB as a helper method.
execute_instance_hooks(
    DYNACONF,  # type: ignore
    "post",
    [
        _hook
        for _hook in DYNACONF._post_hooks
        if getattr(_hook, "_dynaconf_hook", False) is True and not getattr(_hook, "_called", False)
    ],
)

# Load settings validators from environment-specific file (e.g., production.py, development.py)
if (env_settings := Path(apps_settings_dir / f"{environment}.py")).exists():
    env_module = import_module(f"apps.settings.{environment}")
    if hasattr(env_module, "validators"):
        DYNACONF.validators.register(*env_module.validators)

# Update django.conf.settings with DYNACONF keys.
export(__name__, DYNACONF, validation=True)

## --- End Settings | After this line only post validation can happen --- #
